{"ast":null,"code":"require('dotenv').config({\n  path: './../.env'\n});\n\nconst crypto = require('crypto');\n\nvar shell = require('shelljs');\n\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n};\n\nconst webhookPayloadParser = req => new Promise(resolve => {\n  let data = '';\n  req.on('data', chunk => {\n    data += chunk;\n  });\n  req.on('end', () => {\n    resolve(Buffer.from(data).toString());\n  });\n});\n\nfunction verifyPostData(req, res) {\n  return new Promise((resolve, rej) => {\n    if (!req.rawBody) {\n      resolve(false);\n    }\n\n    const sig = Buffer.from(req.headers[process.env.HOOKS_HEADER_NAME] || '', 'utf8');\n    const hmac = crypto.createHmac(process.env.HOOKS_SHA, process.env.HOOKS_SECRET);\n    const digest = Buffer.from(process.env.HOOKS_SHA + '=' + hmac.update(req.rawBody).digest('hex'), 'utf8');\n\n    if (sig.length !== digest.length || !crypto.timingSafeEqual(digest, sig)) {\n      console.log(`Request body digest (${digest}) did not match ${process.env.HOOKS_HEADER_NAME} (${sig})`);\n      resolve(false);\n    } else {\n      let json_string = decodeURIComponent(req.rawBody).split('payload=')[1];\n      let json = JSON.parse(json_string);\n      resolve(json.ref === 'refs/heads/compiled' ? true : false);\n    }\n  });\n}\n\nexport default async function handler(req, res) {\n  const data = await webhookPayloadParser(req);\n  req.rawBody = data;\n  let allowed = await verifyPostData(req, res);\n  console.log('hook received');\n\n  if (allowed) {\n    shell.exec('echo \"working\" & yarn update:server &');\n  } //set out to execute the command\n\n\n  res.statusCode = 200;\n  res.json({});\n}","map":null,"metadata":{},"sourceType":"module"}